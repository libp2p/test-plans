name: "libp2p transport interop test (self-hosted)"
description: "Run the libp2p transport interoperability test suite on self-hosted runner with local disk cache"
inputs:
  test-filter:
    description: "Filter which tests to run out of the created matrix"
    required: false
    default: ""
  test-ignore:
    description: "Exclude tests from the created matrix that include this string in their name"
    required: false
    default: ""
  test-root:
    description: "Path to the transport-interop folder"
    required: true
  upload-results:
    description: "Upload the test results as an artifact"
    required: false
    default: "true"
  extra-versions:
    description: "Space-separated paths to JSON files describing additional images"
    required: false
    default: ""
  s3-cache-bucket:
    description: "Which S3 bucket to use for container layer caching"
    required: false
    default: ""
  s3-access-key-id:
    description: "S3 Access key id for the cache"
    required: false
    default: ""
  s3-secret-access-key:
    description: "S3 secret key id for the cache"
    required: false
    default: ""
  aws-region:
    description: "Which AWS region to use"
    required: false
    default: "us-east-1"
  worker-count:
    description: "How many workers to use for the test"
    required: false
    default: "2"
  timeout:
    description: "How many seconds to let each test run for"
    required: false
  verbose:
    description: "Enable verbose output"
    required: false
    default: false
  cache-dir:
    description: "Local directory to use for build cache"
    required: false
    default: "/srv/cache"
  test-results-suffix:
    description: "Suffix to add to the test results artifact name"
    required: false
    default: ""
runs:
  using: "composite"
  defaults:
    run:
      shell: bash
  steps:
    - name: Configure AWS credentials for S3 build cache
      if: inputs.s3-access-key-id != '' && inputs.s3-secret-access-key != ''
      run: |
        echo "PUSH_CACHE=true" >> $GITHUB_ENV

    # This depends on where this file is within this repository. This walks up
    # from here to the transport-interop folder
    - run: |
        WORK_DIR=$(realpath "$GITHUB_ACTION_PATH/../../../transport-interop")
        echo "WORK_DIR=$WORK_DIR" >> $GITHUB_OUTPUT
      id: find-workdir

    - uses: actions/setup-node@v4
      with:
        node-version: 20

    # Existence of /etc/buildkit/buildkitd.toml indicates that this is a
    # self-hosted runner. If so, we need to pass the config to the buildx
    # action. The config enables docker.io proxy which is required to
    # work around docker hub rate limiting.
    - run: |
        if test -f /etc/buildkit/buildkitd.toml; then
          echo "config=/etc/buildkit/buildkitd.toml" >> $GITHUB_OUTPUT
        fi
      id: buildkit

    - name: Install more recent docker-compose version # https://stackoverflow.com/questions/54331949/having-networking-issues-with-docker-compose
      run: |
        mkdir -p $HOME/.docker/cli-plugins
        wget -q -O- https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-linux-x86_64 > $HOME/.docker/cli-plugins/docker-compose
        chmod +x $HOME/.docker/cli-plugins/docker-compose
        docker compose version

    - name: Set up Docker Buildx
      id: buildx
      uses: docker/setup-buildx-action@v3
      with:
        config: ${{ steps.buildkit.outputs.config }}
        version: v0.29.1
        driver-opts: image=moby/buildkit:v0.25.2

    - name: Create cache directories
      run: |
        mkdir -p ${{ inputs.cache-dir }}/buildCache
        mkdir -p ${{ inputs.cache-dir }}/imageCache

    - name: Install deps
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      run: npm ci

    - name: Load cache and build
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      env:
        CACHE_DIR: ${{ inputs.cache-dir }}
        NAME_FILTER: ${{ inputs.test-filter }}
        NAME_IGNORE: ${{ inputs.test-ignore }}
        VERBOSE: ${{ inputs.verbose }}
        AWS_BUCKET: ${{ inputs.s3-cache-bucket }}
        AWS_REGION: ${{ inputs.aws-region }}
        AWS_ACCESS_KEY_ID: ${{ inputs.s3-access-key-id }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.s3-secret-access-key }}
      run: npm run cache -- load --name-filter="$NAME_FILTER" --name-ignore="$NAME_IGNORE" --verbose="$VERBOSE"

    - name: Assert Git tree is clean.
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      run: |
        if [[ -n "$(git status --porcelain)" ]]; then
          echo "Git tree is dirty. This means that building an impl generated something that should probably be .gitignore'd"
          git status
          exit 1
        fi

    - name: Push the image cache
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      env:
        CACHE_DIR: ${{ inputs.cache-dir }}
        NAME_FILTER: ${{ inputs.test-filter }}
        NAME_IGNORE: ${{ inputs.test-ignore }}
        VERBOSE: ${{ inputs.verbose }}
      run: npm run cache -- push --name-filter="$NAME_FILTER" --name-ignore="$NAME_IGNORE" --verbose="$VERBOSE"

    - name: Run the test
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      env:
        WORKER_COUNT: ${{ inputs.worker-count }}
        EXTRA_VERSION: ${{ inputs.extra-versions }}
        NAME_FILTER: ${{ inputs.test-filter }}
        NAME_IGNORE: ${{ inputs.test-ignore }}
        TIMEOUT: ${{ inputs.timeout }}
        VERBOSE: ${{ inputs.verbose }}
      run: npm run test -- --extra-version=$EXTRA_VERSION --name-filter="$NAME_FILTER" --name-ignore="$NAME_IGNORE" --verbose="$VERBOSE"

    - name: Print the results
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      run: cat results.csv

    - name: Render results
      working-directory: ${{ steps.find-workdir.outputs.WORK_DIR }}
      run: |
        npm run renderResults > "${{ inputs.test-root }}/dashboard.md"

    - name: Update README.md with dashboard.md
      run: |
        DASHBOARD="${{ inputs.test-root }}dashboard.md"
        README="${{ inputs.test-root }}README.md"

        # Ensure both files exist
        [ -f "$DASHBOARD" ] || { echo "Error: $DASHBOARD not found"; exit 1; }
        [ -f "$README" ] || { echo "Error: $README not found"; exit 1; }

        # Escape forward slashes and newlines in dashboard content
        ESCAPED_CONTENT=$(cat "$DASHBOARD" | sed 's/[\/&]/\\&/g' | sed ':a;N;$!ba;s/\n/\\n/g')

        # Replace content between markers
        sed -i '/<!--INTEROP_DASHBOARD_START-->/,/<!--INTEROP_DASHBOARD_END-->/c\<!--INTEROP_DASHBOARD_START-->\n'"$ESCAPED_CONTENT"'\n<!--INTEROP_DASHBOARD_END-->' "$README"

        # Stage both files
        git add "$DASHBOARD" "$README"

        # Commit only if there are changes
        git commit -m "chore: update dashboard and README [ci skip]" || echo "No changes to commit"

        # Push
        git push origin HEAD:${{ github.ref_name }}

    - name: Show Dashboard Output
      run: cat "${{ inputs.test-root }}/dashboard.md" >> $GITHUB_STEP_SUMMARY

    - name: Upload test results
      if: ${{ inputs.upload-results == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.test-results-suffix && format('test-plans-output-{0}', inputs.test-results-suffix) || 'test-plans-output' }}
        path: |
          ${{ steps.find-workdir.outputs.WORK_DIR }}/results.csv
          ${{ inputs.test-root }}/dashboard.md
