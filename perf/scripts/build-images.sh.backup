#!/bin/bash
# Build Docker images for perf implementations
# Accepts optional filter parameter like transport version

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR/.."

source "scripts/lib-perf.sh"
source "../scripts/lib-image-naming.sh"

FILTER="${1:-}"  # Optional: pipe-separated filter (e.g., "go-v0.45|rust-v0.56")
FORCE_IMAGE_REBUILD="${2:-false}"

echo "  → Cache directory: $CACHE_DIR"
if [ -n "$FILTER" ]; then
    echo "  → Filter: $FILTER"
fi
echo ""

# Get all implementations from impls.yaml
impl_count=$(yq eval '.implementations | length' impls.yaml)

# Track which servers need which images
declare -A server_images_local=()
declare -A server_images_remote=()

for ((i=0; i<impl_count; i++)); do
  impl_id=$(yq eval ".implementations[$i].id" impls.yaml)

  # Apply filter if specified
  if [ -n "$FILTER" ]; then
      match_found=false
      IFS='|' read -ra FILTER_PATTERNS <<< "$FILTER"
      for pattern in "${FILTER_PATTERNS[@]}"; do
          if [[ "$impl_id" == *"$pattern"* ]]; then
              match_found=true
              break
          fi
      done
      if [ "$match_found" = false ]; then
          continue
      fi
  fi

  impl_name=$(get_impl_metadata "$impl_id" "name")
  server_id=$(get_server_config "$impl_id")
  source_path=$(yq eval ".implementations[$i].source.path" impls.yaml)
  source_type=$(yq eval ".implementations[$i].source.type" impls.yaml)
  dockerfile=$(yq eval ".implementations[$i].source.dockerfile // \"Dockerfile\"" impls.yaml)

  image_name="perf-${impl_id}"

  echo "╲ Building: $impl_id"
  echo " ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔"
  echo "→ Type: $source_type"
  if [ "$DEBUG" = "true" ]; then
      echo "  Implementation: $impl_id"
      echo "  Source: $source_path"
      echo "  Server: $server_id"
  fi

  # Check if we need to build locally (client always needs image)
  build_local=true

  # Check if image already exists and force rebuild not requested
  if [ "$FORCE_IMAGE_REBUILD" != "true" ] && docker_image_exists "$image_name"; then
    echo "  ✓ Image exists: $image_name (skipping build)"
    echo ""
    # Skip to next implementation
    continue
  fi

  # Build locally if needed
  if [ "$build_local" = "true" ]; then
    if [ ! -d "$source_path" ]; then
      echo "  ✗ Source path not found: $source_path"
      echo "  NOTE: This is expected if you haven't created Dockerfiles yet."
      echo ""
      continue
    fi

    echo "  → Building locally..."
    docker build \
      -t "$image_name" \
      -f "$source_path/$dockerfile" \
      "$source_path" 2>&1 | sed 's/^/    /' || {
      echo "  ✗ Failed to build $image_name"
      exit 1
    }
    echo "  ✓ Built: $image_name"
  fi
  echo ""

  # Build on remote server if needed
  if is_remote_server "$server_id"; then
    hostname=$(get_remote_hostname "$server_id")
    username=$(get_remote_username "$server_id")

    # Check if image exists on remote
    build_remote=true
    if [ "$FORCE_IMAGE_REBUILD" != "true" ]; then
      if exec_on_server "$server_id" "docker image inspect $image_name" >/dev/null 2>&1; then
        log_info "  → Image exists on $server_id (skipping build)"
        build_remote=false
      fi
    fi

    if [ "$build_remote" = "true" ]; then
      log_info "  → Building on remote server $server_id..."

      # Copy source to remote
      log_debug "    Copying source to ${username}@${hostname}..."
      rsync -az --quiet "$source_path/" "${username}@${hostname}:/tmp/perf-test/build-${impl_id}/" || {
        log_error "  Failed to copy source to $server_id"
        exit 1
      }

      # Build on remote
      log_debug "    Building Docker image on remote..."
      exec_on_server "$server_id" \
        "cd /tmp/perf-test/build-${impl_id} && docker build -t $image_name -f $dockerfile ." 2>&1 | sed 's/^/    /' || {
        log_error "  Failed to build $image_name on $server_id"
        exit 1
      }

      echo "  ✓ Built on $server_id: $image_name"

      # Cleanup build directory on remote
      exec_on_server "$server_id" "rm -rf /tmp/perf-test/build-${impl_id}" >/dev/null 2>&1 || true
    fi
  fi
done

log_info "All images built successfully"
